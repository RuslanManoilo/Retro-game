class t{draw(t){t.fillRect(this.x,this.y,this.width,this.height)}update(){this.game.keys.indexOf("ArrowLeft")>-1&&(this.x-=this.speed),this.game.keys.indexOf("ArrowRight")>-1&&(this.x+=this.speed),this.x<.5*-this.width?this.x=.5*-this.width:this.x>this.game.width-.5*this.width&&(this.x=this.game.width-.5*this.width)}shoot(){const t=this.game.getProjectile();t&&t.start(this.x+.5*this.width,this.y)}constructor(t){this.game=t,this.width=100,this.height=100,this.x=.5*this.game.width-.5*this.width,this.y=this.game.height-this.height,this.speed=5}}class e{draw(t){this.free||t.fillRect(this.x,this.y,this.width,this.height)}update(){this.free||(this.y-=this.speed),this.y<-this.height&&this.reset()}start(t,e){this.x=t-.5*this.width,this.y=e,this.free=!1}reset(){this.free=!0}constructor(){this.width=30,this.height=20,this.x=0,this.y=0,this.speed=20,this.free=!0}}class i{draw(t){t.strokeRect(this.x,this.y,this.width,this.height)}update(t,e){this.x=t+this.positionX,this.y=e+this.positionY,this.game.projectilesPool.forEach((t=>{!t.free&&this.game.checkCollision(this,t)&&(this.markedForDeletion=!0,t.reset())}))}constructor(t,e,i){this.game=t,this.width=this.game.enemySize,this.height=this.game.enemySize,this.x=0,this.y=0,this.positionX=e,this.positionY=i,this.markedForDeletion=!1}}class s{render(t){this.y<0&&(this.y+=5),this.speedY=0,(this.x<0||this.x>this.game.width-this.width)&&(this.speedX*=-1,this.speedY=this.game.enemySize),this.x+=this.speedX,this.y+=this.speedY,this.enemies.forEach((e=>{e.update(this.x,this.y),e.draw(t)})),this.enemies=this.enemies.filter((t=>!t.markedForDeletion))}create(){for(let t=0;t<this.game.rows;t++)for(let e=0;e<this.game.columns;e++){let s=e*this.game.enemySize,h=t*this.game.enemySize;this.enemies.push(new i(this.game,s,h))}}constructor(t){this.game=t,this.width=this.game.columns*this.game.enemySize,this.height=this.game.rows*this.game.enemySize,this.x=0,this.y=-this.height,this.speedX=3,this.speedY=0,this.enemies=[],this.create()}}class h{render(t){this.player.draw(t),this.player.update(),this.projectilesPool.forEach((e=>{e.update(),e.draw(t)})),this.waves.forEach((e=>{e.render(t)}))}createProjectiles(){for(let t=0;t<this.numberOfProjectiles;t++)this.projectilesPool.push(new e)}getProjectile(){for(let t=0;t<this.projectilesPool.length;t++)if(this.projectilesPool[t].free)return this.projectilesPool[t]}checkCollision(t,e){return t.x<e.x+e.width&&t.x+t.width>e.x&&t.y<e.y+e.height&&t.y+t.height>e.y}constructor(e){this.canvas=e,this.width=this.canvas.width,this.height=this.canvas.height,this.keys=[],this.player=new t(this),this.projectilesPool=[],this.numberOfProjectiles=10,this.createProjectiles(),this.columns=5,this.rows=3,this.enemySize=60,this.waves=[],this.waves.push(new s(this)),window.addEventListener("keydown",(t=>{-1===this.keys.indexOf(t.key)&&this.keys.push(t.key),"1"===t.key&&this.player.shoot()})),window.addEventListener("keyup",(t=>{const e=this.keys.indexOf(t.key);e>-1&&this.keys.splice(e,1)}))}}window.addEventListener("load",(function(){const t=document.getElementById("canvas1"),e=t.getContext("2d");t.width=600,t.height=800,e.fillStyle="white",e.strokeStyle="white",e.lineWidth=5;const i=new h(t);!function s(){e.clearRect(0,0,t.width,t.height),i.render(e),requestAnimationFrame(s)}()}));
//# sourceMappingURL=index.3ac8b14b.js.map
